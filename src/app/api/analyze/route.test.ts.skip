import { POST } from './route';
import { NextRequest } from 'next/server';

// Mock the Anthropic SDK
jest.mock('@anthropic-ai/sdk', () => {
  return jest.fn().mockImplementation(() => ({
    messages: {
      create: jest.fn(),
    },
  }));
});

// Mock youtubei.js
jest.mock('youtubei.js', () => ({
  Innertube: {
    create: jest.fn(),
  },
}));

describe('API Route: /api/analyze', () => {
  const mockAnthropicCreate = jest.fn();
  const mockYoutubeGetInfo = jest.fn();
  const mockGetTranscript = jest.fn();

  beforeEach(() => {
    jest.clearAllMocks();

    // Setup Anthropic mock
    const Anthropic = require('@anthropic-ai/sdk');
    Anthropic.mockImplementation(() => ({
      messages: {
        create: mockAnthropicCreate,
      },
    }));

    // Setup Youtube mock
    const { Innertube } = require('youtubei.js');
    Innertube.create.mockResolvedValue({
      getInfo: mockYoutubeGetInfo,
    });
  });

  describe('Input validation', () => {
    it('returns 400 if URL is missing', async () => {
      const request = new NextRequest('http://localhost:3000/api/analyze', {
        method: 'POST',
        body: JSON.stringify({}),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(400);
      expect(data.error).toBe('YouTube URL is required');
    });

    it('returns 400 if URL is invalid', async () => {
      const request = new NextRequest('http://localhost:3000/api/analyze', {
        method: 'POST',
        body: JSON.stringify({ url: 'not-a-youtube-url' }),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(400);
      expect(data.error).toBe('Invalid YouTube URL');
    });
  });

  describe('Video ID extraction', () => {
    it('extracts video ID from standard YouTube URL', async () => {
      mockYoutubeGetInfo.mockResolvedValue({
        getTranscript: mockGetTranscript,
      });
      mockGetTranscript.mockResolvedValue({
        transcript: {
          content: {
            body: {
              initial_segments: [
                { snippet: { text: 'Hello' }, start_ms: 0 },
              ],
            },
          },
        },
      });
      mockAnthropicCreate.mockResolvedValue({
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              title: 'Test',
              keyInsights: [],
              deepSummary: [],
              keyMoments: [],
              mustWatch: { timestamp: '0:00', description: 'test' },
            }),
          },
        ],
      });

      const request = new NextRequest('http://localhost:3000/api/analyze', {
        method: 'POST',
        body: JSON.stringify({ url: 'https://youtube.com/watch?v=abc123' }),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(data.videoId).toBe('abc123');
    });

    it('extracts video ID from youtu.be URL', async () => {
      mockYoutubeGetInfo.mockResolvedValue({
        getTranscript: mockGetTranscript,
      });
      mockGetTranscript.mockResolvedValue({
        transcript: {
          content: {
            body: {
              initial_segments: [
                { snippet: { text: 'Hello' }, start_ms: 0 },
              ],
            },
          },
        },
      });
      mockAnthropicCreate.mockResolvedValue({
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              title: 'Test',
              keyInsights: [],
              deepSummary: [],
              keyMoments: [],
              mustWatch: { timestamp: '0:00', description: 'test' },
            }),
          },
        ],
      });

      const request = new NextRequest('http://localhost:3000/api/analyze', {
        method: 'POST',
        body: JSON.stringify({ url: 'https://youtu.be/xyz789' }),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(data.videoId).toBe('xyz789');
    });

    it('extracts video ID from embed URL', async () => {
      mockYoutubeGetInfo.mockResolvedValue({
        getTranscript: mockGetTranscript,
      });
      mockGetTranscript.mockResolvedValue({
        transcript: {
          content: {
            body: {
              initial_segments: [
                { snippet: { text: 'Hello' }, start_ms: 0 },
              ],
            },
          },
        },
      });
      mockAnthropicCreate.mockResolvedValue({
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              title: 'Test',
              keyInsights: [],
              deepSummary: [],
              keyMoments: [],
              mustWatch: { timestamp: '0:00', description: 'test' },
            }),
          },
        ],
      });

      const request = new NextRequest('http://localhost:3000/api/analyze', {
        method: 'POST',
        body: JSON.stringify({ url: 'https://youtube.com/embed/embed123' }),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(data.videoId).toBe('embed123');
    });
  });

  describe('Transcript fetching', () => {
    it('returns 404 if transcript is not available', async () => {
      mockYoutubeGetInfo.mockResolvedValue({
        getTranscript: mockGetTranscript,
      });
      mockGetTranscript.mockRejectedValue(new Error('No transcript available'));

      const request = new NextRequest('http://localhost:3000/api/analyze', {
        method: 'POST',
        body: JSON.stringify({ url: 'https://youtube.com/watch?v=abc123' }),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(404);
      expect(data.error).toContain('Could not fetch transcript');
    });

    it('returns 404 if transcript is empty', async () => {
      mockYoutubeGetInfo.mockResolvedValue({
        getTranscript: mockGetTranscript,
      });
      mockGetTranscript.mockResolvedValue({
        transcript: {
          content: {
            body: {
              initial_segments: [],
            },
          },
        },
      });

      const request = new NextRequest('http://localhost:3000/api/analyze', {
        method: 'POST',
        body: JSON.stringify({ url: 'https://youtube.com/watch?v=abc123' }),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(404);
      expect(data.error).toContain('Could not fetch transcript');
    });
  });

  describe('Claude API integration', () => {
    it('calls Claude API with formatted transcript', async () => {
      mockYoutubeGetInfo.mockResolvedValue({
        getTranscript: mockGetTranscript,
      });
      mockGetTranscript.mockResolvedValue({
        transcript: {
          content: {
            body: {
              initial_segments: [
                { snippet: { text: 'Hello world' }, start_ms: 0 },
                { snippet: { text: 'This is a test' }, start_ms: 5000 },
              ],
            },
          },
        },
      });
      mockAnthropicCreate.mockResolvedValue({
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              title: 'Test Video',
              keyInsights: ['Insight 1', 'Insight 2'],
              deepSummary: ['Summary paragraph 1'],
              keyMoments: [{ timestamp: '0:05', label: 'Start' }],
              mustWatch: { timestamp: '0:10', description: 'Best part' },
            }),
          },
        ],
      });

      const request = new NextRequest('http://localhost:3000/api/analyze', {
        method: 'POST',
        body: JSON.stringify({ url: 'https://youtube.com/watch?v=abc123' }),
      });

      await POST(request);

      expect(mockAnthropicCreate).toHaveBeenCalledWith(
        expect.objectContaining({
          model: 'claude-3-haiku-20240307',
          max_tokens: 4096,
          messages: expect.arrayContaining([
            expect.objectContaining({
              role: 'user',
              content: expect.stringContaining('[0s] Hello world'),
            }),
          ]),
        })
      );
    });

    it('returns analysis data on success', async () => {
      mockYoutubeGetInfo.mockResolvedValue({
        getTranscript: mockGetTranscript,
      });
      mockGetTranscript.mockResolvedValue({
        transcript: {
          content: {
            body: {
              initial_segments: [
                { snippet: { text: 'Test' }, start_ms: 0 },
              ],
            },
          },
        },
      });
      mockAnthropicCreate.mockResolvedValue({
        content: [
          {
            type: 'text',
            text: JSON.stringify({
              title: 'Test Video',
              keyInsights: ['Insight 1'],
              deepSummary: ['Summary 1'],
              keyMoments: [{ timestamp: '0:05', label: 'Start' }],
              mustWatch: { timestamp: '0:10', description: 'Best part' },
            }),
          },
        ],
      });

      const request = new NextRequest('http://localhost:3000/api/analyze', {
        method: 'POST',
        body: JSON.stringify({ url: 'https://youtube.com/watch?v=test123' }),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(200);
      expect(data).toEqual({
        videoId: 'test123',
        videoUrl: 'https://www.youtube.com/watch?v=test123',
        title: 'Test Video',
        keyInsights: ['Insight 1'],
        deepSummary: ['Summary 1'],
        keyMoments: [{ timestamp: '0:05', label: 'Start' }],
        mustWatch: { timestamp: '0:10', description: 'Best part' },
      });
    });
  });

  describe('Error handling', () => {
    it('returns 500 on unexpected errors', async () => {
      mockYoutubeGetInfo.mockRejectedValue(new Error('Unexpected error'));

      const request = new NextRequest('http://localhost:3000/api/analyze', {
        method: 'POST',
        body: JSON.stringify({ url: 'https://youtube.com/watch?v=abc123' }),
      });

      const response = await POST(request);
      const data = await response.json();

      expect(response.status).toBe(404);
      expect(data.error).toBeDefined();
    });
  });
});
